package test

import (
	"embed"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"math/big"
	"strings"
)

// compile and embed all contracts
// note: other interesting parameters for the solidity compiler include:
// --opcodes to get the compiled code in a "readable" opcode format
// --storage-layout to get the storage layout of the contract
//go:generate solc --bin --bin-runtime --hashes --optimize -o compiled --overwrite Storage.sol OpCodes.sol DelegateCaller.sol DelegateReceiver.sol NativeInterop.sol
//go:embed compiled
var compiled embed.FS

// load contracts from embedded compiled data
var (
	Storage          = StorageContract{newContract("compiled/Storage")}
	OpCodes          = OpCodesContract{newContract("compiled/OpCodes")}
	DelegateCaller   = DelegateCallerContract{newContract("compiled/DelegateCaller")}
	DelegateReceiver = DelegateReceiverContract{newContract("compiled/DelegateReceiver")}
	NativeInterop    = NativeInteropContract{newContract("compiled/NativeInterop")}
)

type contract struct {
	deployCode  []byte
	runtimeCode []byte
	signatures  []string
}

func newContract(path string) *contract {
	return &contract{
		deployCode:  common.FromHex(mustRead(compiled, path+".bin")),
		runtimeCode: common.FromHex(mustRead(compiled, path+".bin-runtime")),
		signatures:  strings.Split(strings.ToLower(mustRead(compiled, path+".signatures")), "\n"),
	}
}

func mustRead(data embed.FS, path string) string {
	content, err := data.ReadFile(path)
	if err != nil {
		panic(fmt.Sprintf("failed to read test contract file: %v", path))
	}
	return string(content)
}

func (c *contract) Deploy() []byte {
	return c.deployCode
}

func (c *contract) RuntimeCode() []byte {
	return c.runtimeCode
}

// findSignature iterates the lines of a Signatures file generated by the Solidity compiler
// and returns the signature bytes of the first function containing the given pattern in its name
func (c *contract) findSignature(pattern string) []byte {
	pattern = strings.ToLower(pattern)
	for _, sig := range c.signatures {
		if strings.Contains(sig, pattern) {
			return common.FromHex(sig[:8])
		}
	}
	panic(fmt.Sprintf("no function signature found for: %v", pattern))
}

type StorageContract struct{ *contract }

func (c *StorageContract) Deploy(initialValue *big.Int) []byte {
	return Concat(c.deployCode, common.BigToHash(initialValue).Bytes())
}

func (c *StorageContract) Store(value *big.Int) []byte {
	return Concat(c.findSignature("store"), common.BigToHash(value).Bytes())
}

func (c *StorageContract) Retrieve() []byte {
	return c.findSignature("retrieve")
}

type OpCodesContract struct{ *contract }

func (c *OpCodesContract) Call(name string) []byte {
	return c.findSignature(name)
}

type DelegateReceiverContract struct{ *contract }

func (c *DelegateReceiverContract) Store(value *big.Int) []byte {
	return Concat(c.findSignature("store"), common.BigToHash(value).Bytes())
}

func (c *DelegateReceiverContract) Retrieve() []byte {
	return c.findSignature("retrieve")
}

type DelegateCallerContract struct{ *contract }

func (c *DelegateCallerContract) Store(address *common.Address, value *big.Int) []byte {
	return Concat(
		c.findSignature("store"),
		address.Hash().Bytes(),
		common.BigToHash(value).Bytes(),
	)
}

func (c *DelegateCallerContract) Retrieve() []byte {
	return c.findSignature("retrieve")
}

type NativeInteropContract struct{ *contract }

func (c *NativeInteropContract) GetForgerStakes() []byte {
	return c.findSignature("GetForgerStakes")
}
