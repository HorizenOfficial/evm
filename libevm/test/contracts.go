package test

import (
	_ "embed"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"math/big"
	"strings"
)

//go:generate solc --bin --bin-runtime --hashes --opcodes --storage-layout --optimize -o compiled --overwrite Storage.sol
var (
	//go:embed compiled/Storage.bin
	storageDeployCode string
	//go:embed compiled/Storage.bin-runtime
	storageRuntimeCode string
	//go:embed compiled/Storage.signatures
	storageSignatures string

	Storage = StorageContract{New(storageDeployCode, storageRuntimeCode, storageSignatures)}
)

//go:generate solc --bin --bin-runtime --hashes --opcodes --storage-layout --optimize -o compiled --overwrite OpCodes.sol
var (
	//go:embed compiled/OpCodes.bin
	opCodesDeployCode string
	//go:embed compiled/OpCodes.bin-runtime
	opCodesRuntimeCode string
	//go:embed compiled/OpCodes.signatures
	opCodesSignatures string

	OpCodes = OpCodesContract{New(opCodesDeployCode, opCodesRuntimeCode, opCodesSignatures)}
)

//go:generate solc --bin --bin-runtime --hashes --opcodes --storage-layout --optimize -o compiled --overwrite DelegateCaller.sol
//go:generate solc --bin --bin-runtime --hashes --opcodes --storage-layout --optimize -o compiled --overwrite DelegateReceiver.sol
var (
	//go:embed compiled/DelegateCaller.bin
	delegateCallerDeployCode string
	//go:embed compiled/DelegateCaller.bin-runtime
	delegateCallerRuntimeCode string
	//go:embed compiled/DelegateCaller.signatures
	delegateCallerSignatures string
	//go:embed compiled/DelegateReceiver.bin
	delegateReceiverDeployCode string
	//go:embed compiled/DelegateReceiver.bin-runtime
	delegateReceiverRuntimeCode string
	//go:embed compiled/DelegateReceiver.signatures
	delegateReceiverSignatures string

	DelegateCaller = DelegateCallerContract{
		New(delegateCallerDeployCode, delegateCallerRuntimeCode, delegateCallerSignatures),
	}
	DelegateReceiver = DelegateReceiverContract{
		New(delegateReceiverDeployCode, delegateReceiverRuntimeCode, delegateReceiverSignatures),
	}
)

type Contract struct {
	deployCode  []byte
	runtimeCode []byte
	signatures  []string
}

func New(deployCode, runtimeCode, signatures string) *Contract {
	return &Contract{
		deployCode:  common.FromHex(deployCode),
		runtimeCode: common.FromHex(runtimeCode),
		signatures:  strings.Split(strings.ToLower(signatures), "\n"),
	}
}

func (c *Contract) Deploy() []byte {
	return c.deployCode
}

func (c *Contract) RuntimeCode() []byte {
	return c.runtimeCode
}

// findSignature iterates the lines of a Signatures file generated by the Solidity compiler
// and returns the signature bytes of the first function containing the given pattern in its name
func (c *Contract) findSignature(pattern string) []byte {
	pattern = strings.ToLower(pattern)
	for _, sig := range c.signatures {
		if strings.Contains(sig, pattern) {
			return common.FromHex(sig[:8])
		}
	}
	panic(fmt.Sprintf("no function signature found for: %v", pattern))
}

type StorageContract struct {
	*Contract
}

func (c *StorageContract) Deploy(initialValue *big.Int) []byte {
	return concat(c.deployCode, common.BigToHash(initialValue).Bytes())
}

func (c *StorageContract) Store(value *big.Int) []byte {
	return concat(c.findSignature("store"), common.BigToHash(value).Bytes())
}

func (c *StorageContract) Retrieve() []byte {
	return c.findSignature("retrieve")
}

type OpCodesContract struct {
	*Contract
}

func (c *OpCodesContract) Call(name string) []byte {
	return c.findSignature(name)
}

type DelegateCallerContract struct {
	*Contract
}

func (c *DelegateCallerContract) Store(value *big.Int, address *common.Address) []byte {
	return concat(
		c.findSignature("store"),
		common.BigToHash(value).Bytes(),
		address.Hash().Bytes(),
	)
}

func (c *DelegateCallerContract) Retrieve() []byte {
	return c.findSignature("retrieve")
}

type DelegateReceiverContract struct {
	*Contract
}

func (c *DelegateReceiverContract) Store(value *big.Int) []byte {
	return concat(c.findSignature("store"), common.BigToHash(value).Bytes())
}

func (c *DelegateReceiverContract) Retrieve() []byte {
	return c.findSignature("retrieve")
}

func concat(slices ...[]byte) []byte {
	var length int
	for _, s := range slices {
		length += len(s)
	}
	tmp := make([]byte, length)
	var i int
	for _, s := range slices {
		i += copy(tmp[i:], s)
	}
	return tmp
}
